---
id: design-principles
title: 設計原則
layout: contributing
permalink: docs/design-principles.html
prev: implementation-notes.html
redirect_from:
  - "contributing/design-principles.html"
---

このドキュメントを作成したのは、React が何をして何をしないのか、そして開発理念がどのようなものなのかをより理解できるようにするためです。私たちはコミュニティへの貢献を見ることにわくわくしています。しかしこれらの原則の 1 つ以上に違反する道を選ぶことはありません。

>**注意:**
>
>このドキュメントは React を強く理解していることを前提としています。React のコンポーネントやアプリケーションではなく、*React 自体*の設計原則について説明しています。
>
>React の紹介については、代わりに [React の流儀](/docs/thinking-in-react.html)を調べてください。

### コンポジション {#composition}

React の主な機能はコンポーネントのコンポジションです。異なる人々によって書かれたコンポーネントは一緒にうまく動くべきです。コードベース全体に波及する変更を引き起こすことなく、コンポーネントに機能を追加できるということが重要です。

たとえば、コンポーネントを使用する側を変更せずに、コンポーネントにローカルステートを導入することが可能です。同様に、必要に応じて初期化と終了処理を任意のコンポーネントに追加することも可能です。

コンポーネントでステートまたはライフサイクルメソッドを使用することについて「悪い」ことは何もありません。他の強力な機能と同様に適度に使用する必要がありますが、私たちはそれらを削除するつもりはありません。それどころか、それらは React を有用にするものとして不可欠な部分であると思います。将来的には[より関数型的なパターン](https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State)を使用可能にするかもしれませんが、ローカルステートとライフサイクルメソッドの両方がそのモデルの一部になるでしょう。

コンポーネントはしばしば「単なる関数」と表現されますが、私たちの見解では、それらは有用であるために単なる関数以上である必要があります。React では、コンポーネントは組み合わせ可能な動作を記述します。そしてこれには、レンダリング、ライフサイクル、およびステートが含まれます。[Relay](http://facebook.github.io/relay/) のようないくつかの外部ライブラリは、データの依存関係を記述するといったような他の責任でコンポーネントを補強します。それらのアイデアが何らかの形で React にも戻るということも有り得ます。

### 共通の抽象化 {#common-abstraction}

一般的に私達はユーザーランドに実装できる[機能の追加に抵抗](https://www.youtube.com/watch?v=4anAwXYqLG8)します。使用されない無駄なライブラリコードであなたのアプリを肥大化させたくありません。ただし、これには例外があります。

たとえば、React がローカルステートやライフサイクルメソッドをサポートしていない場合、人々はそれらに対してカスタム抽象化を作成します。複数の抽象化が競合している場合、React はそれらのいずれかのプロパティを強制または利用することはできません。それは最小公倍数で動作する必要があります。

これが、React 自体に機能を追加することがある理由です。多くのコンポーネントが互換性のない、または非効率的な方法で特定の機能を実装していることに気づいたら、React にそれを焼き付けるかもしれませんが、私たちは簡単にはそれをしません。それをするときは抽象化レベルを上げることがエコシステム全体に利益をもたらすと確信しているからです。ステート、ライフサイクルメソッド、クロスブラウザのイベント正規化などがその好例です。

私たちは常にそのような改善提案をコミュニティーと話し合います。それらの議論のいくつかは React イシュートラッカーの ["big picture"](https://github.com/facebook/react/issues?q=is:open+is:issue+label:"Type:+Big+Picture")ラベルで見つけることができます。

### 避難ハッチ {#escape-hatches}

React は実用的です。それは Facebook で書かれた製品のニーズによって推進されています。関数型プログラミングなど、まだ完全には主流になっていない、いくつかのパラダイムによって影響を受けますが、さまざまなスキルや経験レベルを持つ幅広い開発者がアクセスしやすいことがプロジェクトの明確な目標です。

私たちが好まないパターンを非推奨にしたい場合は非推奨にする前に、既存のすべてのユースケースを検討し、[コミュニティに代替案について教育する](/blog/2016/07/13/mixins-considered-harmful.html)ことが私たちの責任です。アプリを構築するのに有用なパターンを宣言的に表現するのが難しい場合は、[命令的な API を提供](/docs/more-about-refs.html)します。多くのアプリで必要と思われるものに最適な API を見つけられないときは、後で取り除くことが可能で、将来の改善のためのドアが開いている場合に限り、[一時的な標準以下の作業用 API](/docs/legacy-context.html) を提供します。

### 安定性 {#stability}

API の安定性を重視しています。Facebook では、React を使って 5 万以上のコンポーネントを持っています。[Twitter](https://twitter.com/) や [Airbnb](https://www.airbnb.com/) を含む他の多くの会社もまた React のヘビーユーザーです。これが私たちがパブリック API や振る舞いを変えることに大抵消極的である理由です。

しかし、「何も変わらない」という意味での安定性は過大評価されていると思います。それはすぐに停滞に変わります。代わりに、「本番環境では頻繁に使用され、何かが変わったときには明確な（できれば自動化された）移行方法がある」という意味での安定性を優先します。

パターンを非推奨にするときは、Facebook でその内部使用法を調べ、非推奨警告を追加します。彼らは私たちに変化の影響を評価させます。時期尚早であると判断した場合は戻すことがありますが、コードベースをこの変更の準備が整うまで戦略をさらに検討する必要があります。

変更があまり破壊的でなく、移行戦略がすべてのユースケースで実行可能であると確信している場合は、非推奨の警告をオープンソースコミュニティに公開します。私たちは Facebook 以外の多くの React ユーザーと密接に連絡を取り合っており、人気のあるオープンソースプロジェクトを監視し、非推奨の修正を手引きします。

Facebook の React コードベースのサイズが非常に大きいことを考えると、社内への移行が成功したことは、他の企業でも問題ないことを示す良い指標となります。それでも、時々人々は私達が考えていない追加のユースケースを指摘します、そして私達はそれらのために避難ハッチを追加するかまたは私達のアプローチを再考します。

正当な理由がない限り、私たちは何も非推奨にすることはありません。非推奨警告は時々イライラさせるということを認識していますが、それを追加するのは、私たちとコミュニティの多くの人々が価値あると考える改善と新機能のために、非推奨を解決するためです。

たとえば、React 15.2.0 で[未知の DOM プロップに関する警告](/warnings/unknown-prop.html)を追加しました。多くのプロジェクトがこの影響を受けました。ただし、この警告を修正することは重要です。そのため、React に[カスタム属性](https://github.com/facebook/react/issues/140)のサポートを導入可能にしました。私たちが追加するすべての非推奨の背景には、このような理由があります。

非推奨警告を追加すると、現在のメジャーバージョンの残りの部分については警告が残され、[次のメジャーバージョンでは動作が変更](/blog/2016/02/19/new-versioning-scheme.html)されます。繰り返し行われる手作業が多い場合は、変更の大部分を自動化する [codemod](https://www.youtube.com/watch?v=d0pOgY8__JM) スクリプトをリリースします。Codemod を使用すると、大規模なコードベースでも移行を滞りなく進めることができます。それらを使用することをお勧めします。

私たちがリリースした codemod は、[react-codemod](https://github.com/reactjs/react-codemod) リポジトリで見つけることができます。

### 相互運用性 {#interoperability}

既存のシステムとの相互運用性と段階的な導入に高い価値を置いています。Facebook は巨大な非 React コードベースを持っています。同社の Web サイトでは、XHP と呼ばれるサーバーサイドのコンポーネントシステム、React よりも前に開発された内部 UI ライブラリ、そして React 自体を組み合わせて使用​​しています。私たちにとって重要なことは、どの製品チームでも、賭けるようにコードを書き換えるのではなく、[小さな機能に対して React を使い始める](https://www.youtube.com/watch?v=BF58ZJ1ZQxY)ことができるということです。

これが、React が可変モデルを扱うための避難ハッチを提供し、他の UI ライブラリと一緒にうまく機能しようとする理由です。既存の命令的な UI を宣言型コンポーネントにラップすることも、その逆も可能です。これは段階的な採用には不可欠です。

### スケジューリング {#scheduling}

コンポーネントが関数として記述されていても、React を使うときはそれらを直接呼び出さないでください。すべてのコンポーネントは[何をレンダリングする必要があるかの説明](/blog/2015/12/18/react-components-elements-and-instances.html#elements-describe-the-tree)を返し、その説明には`<LikeButton>`のようなユーザー作成のコンポーネントと`<div>`のようなプラットフォーム固有のコンポーネントの両方を含めることができます。将来のある時点で`<LikeButton>`を「展開」して、コンポーネントの再帰的なレンダリング結果に従って UI ツリーを実際に変更するのは React です。

これは微妙な違いですが強力なものです。あなたがコンポーネント関数を呼び出さずに React が呼び出します。それは React は必要に応じて呼び出しを遅らせる権限があるということを意味します。現在の React の実装ではツリーを再帰的に調べて、1 回の描画の間に更新されたツリー全体のレンダリング関数を呼び出します。しかし、将来的には[フレームのドロップを避けるため](https://github.com/facebook/react/issues/6170)にいくつかの更新を遅らせるかもしれません。

これは React の設計の共通テーマです。いくつかの人気のあるライブラリは、新しいデータが利用可能になったときに計算が実行される「プッシュ」アプローチを実装しています。しかし React は、計算が必要になるまで遅らせることができる「プル」アプローチを採用しています。

React は一般的なデータ処理ライブラリではありません。ユーザーインターフェイスを構築するためのライブラリです。現在どの計算が関連しているのか、どの計算が関連していないのかを知ることは、アプリ内で一意に位置づけられていると考えています。

何かが画面外にある場合は、それに関連するロジックを遅らせることができます。データがフレームレートよりも早く到着する場合は、合体してバッチ更新することができます。フレームを落とさないように、重要度の低いバックグラウンド作業（ネットワークからロードされたばかりの新しいコンテンツのレンダリングなど）よりも、ユーザーの操作による操作（ボタンクリックによるアニメーションなど）を優先できます。

明確にするために、私達は今これを利用していません。しかし、このようなことを自由に行えるのは、スケジューリングを制御したいから、 そして `setState()` が非同期であるからです。概念的には、それを「更新をスケジュールする」と考えています。

ユーザが[関数型リアクティブプログラミング](https://en.wikipedia.org/wiki/Functional_reactive_programming)のいくつかのバリエーションで一般的な「プッシュ」ベースのパラダイムでビューを直接構成させた場合、スケジューリングに対する制御を得るのが難しくなります。私たちは「グルーコード」を所有したいのです。

React の主な目標は、React 内部に戻る前に実行されるユーザーコードの量を最小限にすることです。これは React が UI について知っていることに従ってスケジュールしたりチャンクで作業を分割したりする能力を保持することを保証します。

React は完全に「リアクティブ」であることを望んでいないため、React は「スケジュール」と呼ばれるべきだったというチーム内の冗談があります。

### 開発体験 {#developer-experience}

良い開発者経験を提供することは私達にとって重要です。

たとえば、Chrome と Firefox で React コンポーネントツリーを調べることができる [React DevTools](https://github.com/facebook/react-devtools) を保持しています。私たちは、それが Facebook エンジニアとコミュニティの両方に大きな生産性向上をもたらすと耳にしました。

私たちは開発者向けの有用な警告を提供するために、一層の努力をするようにしています。たとえば、React は開発中にブラウザが理解できない方法でタグをネストした場合、または API で一般的な入力ミスをした場合に警告します。開発者向けの警告とそれに関連するチェックが、React の開発版が製品版より遅い主な理由です。

Facebook で内部的に見られる使用パターンは、よくある間違いとは何か、そしてそれらを早期に防ぐ方法を理解するのに役立ちます。私たちが新しい機能を追加するとき、私たちはよくある間違いを予想してそれらについて警告しようとします。

私たちは開発者の経験を向上させる方法を常に探しています。私たちはあなたの提案を聞き、それをさらに良くするためにあなたの貢献を受け入れることが好きです。

### デバッグ {#debugging}

問題が発生した場合は、コードベースでその間違いの原因を突き止めるためのパンくずを作成することが重要です。React では、props と state はそれらのパンくずです。

画面に問題がある場合は、React DevTools を開いてレンダリングを担当するコンポーネントを見つけ、次に props と state が正しいかどうかを確認できます。そうであれば、問題はコンポーネントの `render()` 関数、または `render()` によって呼び出される関数にあることがわかります。問題は独立しています。

state が間違っている場合、問題はこのファイル内の `setState()` の呼び出しの 1 つによって引き起こされていることがわかります。これも、通常は 1 つのファイル内に `setState()` の呼び出しは数回しかないため、検索と修正が比較的簡単です。

props が間違っている場合は、インスペクタでツリーを上にたどり、悪い props を渡して最初に「井戸に毒を入れた」コンポーネントを探します。

任意の UI から現在の props と state で生成したデータまでたどるこの能力は React にとって非常に重要です。state がクロージャやコンビネータに「閉じ込め」られておらず、React で直接利用できることは明示的な設計目標です。

UI は動的ですが、props と state の同期的な `render()` 関数はデバッグを退屈な推測だが有限の手順に変えると信じています。複雑なアニメーションのようないくつかのユースケースをより困難にしますが、React ではこの制約を保持したいと思います。

### 設定 {#configuration}

グローバルな実行時設定オプションは問題があることがわかりました。

例えば、`React.configure(options)` や `React.register(component)` のような関数を実装することが時々要求されます。しかし、これは複数の問題を引き起こし、私たちはそれらに対する良い解決策を知りません。

誰かがサードパーティのコンポーネントライブラリからそのような関数を呼び出すとどうなりますか？ ある React アプリに別の React アプリが埋め込まれていて、それらの望ましい設定に互換性がない場合はどうなりますか？ サードパーティコンポーネントは特定の設定をどのように必須にしますか？ グローバル設定はコンポジションではうまく機能しないと考えています。コンポジションは React の中心であるため、コードでグローバル設定を提供しません。

ただし、ビルドレベルでグローバル設定をいくつか提供します。たとえば、開発ビルドと本番ビルドを別々に提供しています。将来[プロファイリングビルドを追加する](https://github.com/facebook/react/issues/6627)かもしれませんし、また、他のビルドフラグの検討を受け入れています。

### DOMを超えて {#beyond-the-dom}

私たちは React の価値を、バグの少ないコンポーネントを書いてうまく構成することができるという点で見ています。DOM は React のオリジナルのレンダリングターゲットですが、[React Native](http://facebook.github.io/react-native/) は Facebook とコミュニティの両方において同じくらい重要です。

レンダラーにとらわれないことは React の重要な設計上の制約です。それは内部表現にいくらかのオーバーヘッドを追加します。その一方で、コアへの改善はすべてのプラットフォーム間で変換されます。

単一のプログラミングモデルを持つことで、プラットフォームではなく製品を中心にエンジニアリングチームを形成できます。これまでのところ、そのトレードオフは私たちにとって価値があります。

### 実装 {#implementation}

可能な限り洗練された API を提供しようとしています。実装がエレガントであることにはそれほど関心がありません。現実の世界は完璧には程遠いので、合理的な範囲で、ユーザーが書く必要がないという意味で醜いコードをライブラリに入れることを選びます。新しいコードを評価するときには、正しく、パフォーマンスが高く、優れた開発者エクスペリエンスを提供する実装を探しています。優雅さは第二です。

私たちは賢いコードより退屈なコードを好む。コードは使い捨てであり、しばしば変更されます。したがって、それが[絶対に必要でない限り、新しい内部抽象化を導入しない](https://youtu.be/4anAwXYqLG8?t=13m9s)ことが重要です。移動、変更、削除が容易な冗長コードは、時期尚早に抽象化され変更が難しいエレガントなコードよりも優先されます。

### ツールに最適化 {#optimized-for-tooling}

いくつかの一般的に使用される API は冗長な名前を持っています。例えば、`didMount()` や `onMount()` の代わりに `componentDidMount()` を使います。これは[意図的](https://github.com/reactjs/react-future/issues/40#issuecomment-142442124)です。目的は、ライブラリとのやり取りのポイントをよく見えるようにすることです。

Facebook のような大規模なコードベースでは、特定の API の使用を検索できることが非常に重要です。特に冗長な名前を大切にしています。特に、控えめに使用する必要がある機能については同様です。例えば、`dangerouslySetInnerHTML` はコードレビューで見逃すのが難しいです。

私たちが大きな変更を加える際に [codemods](https://www.youtube.com/watch?v=d0pOgY8__JM) に依存しているため、検索を最適化することも重要です。膨大な自動化された変更をコードベース全体に適用するのが簡単で安全であることを望みます。そして、固有の冗長名を使用すると、これを実現できます。同様に、識別可能な名前を使用すると、潜在的な誤検知を心配することなく、React の使用に関するカスタムの [lint ルール](https://github.com/yannickcr/eslint-plugin-react)を簡単に作成できます。

[JSX](/docs/introducing-jsx.html) も同様の役割を果たします。React では必須ではありませんが、美観上および実用上の理由から、Facebook で広く使用されています。

私たちのコードベースでは、JSX はそれらが React 要素ツリーを扱っているというツールへの明白なヒントを提供します。これにより、[定数要素の巻き上げ](http://babeljs.io/docs/plugins/transform-react-constant-elements/)、安全な lint および codemod 内部コンポーネントの使用などのビルド時の最適化を追加したり、[JSX ソースの場所](https://github.com/facebook/react/pull/6771)を警告に含めることができます。

### ドッグフーディング {#dogfooding}

私たちはコミュニティーによって提起された問題に取り組むために最善を尽くします。しかし、私たちは Facebook *も* 経験しているという問題を優先する可能性があります。直感に反して、私たちはこれがコミュニティが React に賭けることができる主な理由であると思います。

大量の内部使用は、React が明日消えないという自信を私たちに与えます。React は問題を解決するために Facebook で作成されました。それは企業に確かなビジネス価値をもたらし、多くの製品で使用されています。[ドッグフーディング](https://en.wikipedia.org/wiki/Eating_your_own_dog_food)は私たちのビジョンが鮮明なままであり、私たちは今後も焦点を絞った方向性を持っていることを意味します。

これは、コミュニティが提起した問題を無視しているという意味ではありません。たとえば、依存していなくても React に [Web コンポーネント](/docs/webcomponents.html)および [SVG](https://github.com/facebook/react/pull/6243) のサポートをどちらも内部的に追加しました。私達は積極的に[あなたの問題点を聞き](https://github.com/facebook/react/issues/2686)、私たちの能力の及ぶ限りで[それらを対処](/blog/2016/07/11/introducing-reacts-error-code-system.html)します。コミュニティは React を私たちにとって特別なものにしています。そして私たちは貢献してくれて光栄です。

Facebook で多くのオープンソースプロジェクトをリリースした後、みんなを同時に幸せにすることを試みるが焦点が不十分なプロジェクトを生み出してもうまく成長しないということを学びました。代わりに、少人数の観客を選んで満足させることに集中すると的を得た効果があることがわかりました。これこそまさに私たちが React を使って行ったことです、そして今のところ Facebook 製品チームが遭遇した問題を解決することはオープンソースコミュニティにうまく移されました。

このアプローチの欠点は、「getting started」など、Facebook チームが対処する必要がないことに十分に焦点を当てることができないことです。私たちはこのことを強く認識しています、そして私たちは以前にオープンソースプロジェクトで行ったのと同じ過ちを犯さずにコミュニティのすべての人に利益をもたらすような方法で改善する方法を考えています。